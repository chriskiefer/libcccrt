class:: CccRPC
summary:: Random Projection Complexity
related:: TODO
categories:: UGens>Analysis

description::

Calculates the Random Projection Complexity (RPC) of a signal.  RPC can give insights into the regularity or predictability of a signal.  For example, noise will have a high value, and a simple square wave will have a low value. 

Full details of the algorithm are given in the references below; put simply, the algorithm works as follows: RPC is a compression-based metric, which means that it equates the compressabiity of data with its complexity. RPC uses random projection, a lossy compression method.  It works on the principle that when you use a randomly generated matrix to project data from a high dimension to a lower dimension, the distance between data points will be roughly preserved (think about shining a torch on an object, and looking at its shadow, a 3D->2D projection).  This UGen takes a block of the most recent data in a signal, and runs a sliding window across it. The window's width is determined by the size of the higher dimension, from which to make projections.  The window is moved across the block, and the projections in the lower dimensional space are collected. RPC then treats this space as a multi-dimensional histogram, and counts the number of non-zero bins, resulting in a measure of complexity. Intuitively, regular patterns in the signal will be projected onto similar spots in the lower dimensional space, and therefore take up less room in the histogram. Conversely, complex or noisy signals will not have repeating patterns, so they will take up more space in the histogram.



References:

Kiefer, C. 2023. Dynamical complexity measurement with random projection: a metric optimised for realtime signal processing. Sound and Music Computing, Stockholm, Sweden, 12-17 June 2023.
(http://sro.sussex.ac.uk/id/eprint/111991/1/smc2023%20RPC_final.pdf)

Kiefer, C., Overholt, D. and Eldridge, A., 2020. Shaping the behaviour of feedback instruments with complexity-controlled gain dynamics. In 20th International Conference on New Interfaces for Musical Expression (pp. 343-348).
(https://vbn.aau.dk/ws/files/395237786/nime2020_paper66.pdf)


classmethods::

method::ar

argument::input

The input signal

argument::highDim

The size of the higher dimension from which to project (not modulateable)

argument::lowDim

The size of the lower target dimension (not modulateable)

argument::rpcHopSize

The percetage (0-1) of the higher dimension size to jump before making a new RPC projection.

argument::rpcRes

The resolution of the histogram in the low dimensional space

argument::winSize

The size of the sliding window from which to take RPC readings (unit:milliseconds)

argument::hopSize

The percentage (0-1) hop size of the sliding window

argument::maxWinSize

The maximum window size you would expect to use (unit: milliseconds) (not modulateable)


examples::

code::

(
{
	var w = XFade2.ar(WhiteNoise.ar, Saw.ar(100), MouseX.kr(-1,1));
	var rpc=CccRPC.ar(w, 10, 2, 0.5, 20,10,20, 0.5).poll;
	[w, rpc/RunningMax.ar(rpc)]
}.scope
)
::
